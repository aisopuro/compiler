import java.util.Deque;
import java.util.ArrayDeque;
import java.lang.Integer;

COMPILER Grammar

private Printer printer;

private SymbolTable table = new SymbolTable();
private CodeGenerator generator = new CodeGenerator();


// Token types
private static final int UNDEFINED = 0;
private static final int INTEGER = UNDEFINED + 1;
private static final int BOOLEAN = INTEGER + 1;

// @SLX

private String id;

private String out;

private int checkInteger(String value) {
	int val = 0;
	try {
		val = Integer.valueOf(value);
	}
	catch (NumberFormatException e) {
		// Number is too large
		this.SemErr("overflow: integer is too large");
	}
	return val;
}

public Parser(Scanner s, Printer p) {
       this(s);
       this.printer = p;
}

private class OpData {
	public String cw;
	public int expected;
	public int result;
}

CHARACTERS
	letter = 'A'..'Z' + 'a'..'z'.
	digit = '0'..'9'.

TOKENS
	identifier = letter {letter | digit}.
	integer = digit {digit}.

IGNORE '\r'+'\t'+'\n'

PRODUCTIONS

Grammar			(.
					printer.startProduction("Grammar");
				.)
=
MainFuncDecl
EOF				(.
					printer.print("Table: " + table.toString());
					this.generator.halt();
					printer.endProduction("Grammar");
				.)
.

MainFuncDecl	(. printer.startProduction("MainFuncDecl"); .)
=
"main"			(.
				.)
FuncBody		(. printer.endProduction("MainFuncDecl"); .)
.

FuncBody		(. printer.startProduction("FuncBody"); .)
=
"begin"				(.  .)
VarDecl
StatementList
ReturnStatement
"end"				(.

					printer.endProduction("FuncBody");
				.)
.

VarDecl			(.
					int type;
					printer.startProduction("VarDecl"); .)
=
Type<out type>	(.if (type == UNDEFINED) SemErr("Incorrect type declaration");.)
identifier (.
				String name = t.val;
				if (this.table.exists(name)) {
					SemErr("Double variable definition, " + name + " already exists");
				}
				else {
					SymbolTable.Symbol symbol = this.table.add(name, type);
				}
				.)
';'
	VarDecl			(. printer.endProduction("VarDecl"); .)
|
					(.
						printer.print("_");
						printer.endProduction("VarDecl");
					.)
.


StatementList	(. printer.startProduction("StatementList"); .)
=
Statement
StatementList	(. printer.endProduction("StatementList"); .)
|
				(. printer.endProduction("StatementList"); .)
.

ReturnStatement	(. int type; SymbolTable.Symbol symbol; printer.startProduction("ReturnStatement"); .)
=
"return"		(. printer.print("return"); .)
Expr<out type>
";"				(. printer.endProduction("ReturnStatement"); .)
.

Statement		(.
					int type; SymbolTable.Symbol symbol;
					printer.startProduction("Statement"); .)
=
"if"
"("
Expr<out type>
")"				(.
					if (type != BOOLEAN) {
						// ERROR, non-boolean expression in conditional
						this.SemErr("incorrect if-declaration: expected boolean expression");
					}
					else {
						printer.print("if ok");
					}
					int ifEndLabel = this.generator.newLabel();
					this.generator.emit("JZE", ifEndLabel);
				 .)
"then"			(.
					printer.print("then");
				.)
Statement	    (.
					printer.print("fi");
					this.generator.emit("LAB", ifEndLabel);
					printer.endProduction("Statement");
				.)
|
"while"			(.
					printer.print("while");
					int whileEndLabel = this.generator.newLabel();
				 .)
"("
Expr<out type>
")"				(.
					if (type != BOOLEAN) {
						// ERROR, non-boolean expression
						this.SemErr("incorrect while-declaration: expected boolean expression");
					}
					else {
						printer.print("while ok");
					}
					this.generator.emit("JZE", whileEndLabel);
				.)
Statement		(.printer.endProduction("Statement");
					this.generator.emit("LAB", whileEndLabel);
				.)
|
"print"			(.printer.print("print");.)
"("
Expr<out type>
")"				(.
				// @SLX: Print
					this.generator.emit("WRI");
				.)
";"				(.
					printer.endProduction("Statement");
				.)
|
"begin"
StatementList
"end"				(.
					printer.endProduction("Statement");
				.)
|
IdAccess<out symbol>
"<-"
Expr<out type>	(.
					if (symbol.type == type) {
						this.generator.emit("STL");
					}
                    else {
                        SemErr("Type mismatch in assignment: " + symbol.type + " </- " + type);
                    }
				.)
";"				(.
					printer.endProduction("Statement");
				.)
.




Expr<out int type>		(.
							type = UNDEFINED;
							int type1 = UNDEFINED;
							int type2 = UNDEFINED;
							OpData op;
							printer.startProduction("Expr");
						.)
=
BaseExpr<out type1>			(. type = type1; .)
(
op<out op>					(.
								if (type1 != op.expected) {
									SemErr("Unexpected type for " + op.cw);
								}
								type = op.result;
							.)
BaseExpr<out type2>			(.
								if (type2 != op.expected) {
									SemErr("Unexpected type for " + op.cw);
								}
								if (op.cw == "AND") {
									this.generator.emitAnd();
								}
								else {
									this.generator.emit(op.cw);
								}
								printer.endProduction("Expr");.)
|
				(. printer.endProduction("Expr");.)
)
|
"!"				(. printer.print("!"); .)
BaseExpr<out type>		(.
					if (type != BOOLEAN) {
						// Error, negating non-boolean
						this.SemErr("Trying to negate non-boolean expression");
					}
					else {
						this.generator.emit("NOT");
					}
				.)
|
"-"             (. printer.print("-"); .)
BaseExpr<out type>        (.
                    if (type != INTEGER) {
                        // Error, minus of non-integer
                        this.SemErr("trying to take negative of non-integer");
                    }
                    else {
                        this.generator.emit("UMN");
                    }
                .)
.




BaseExpr<out int type>		(.
					SymbolTable.Symbol symbol;
					type = UNDEFINED;
					printer.startProduction("BaseExpr");.)
=
"("				(.
				 .)
Expr<out type>
")"				(.
					printer.endProduction("BaseExpr"); .)
|
IdAccess<out symbol>	(.
 							this.generator.emit("LDL");
							type = symbol.type;
							printer.endProduction("BaseExpr");
						.)
|
integer			(.
					printer.print(t.val);
					int value = this.checkInteger(t.val);
					type = INTEGER;
					this.generator.emit("ENT", value);
					printer.endProduction("BaseExpr");
				 .)
|
"true"			(.
					printer.print(t.val);
					this.generator.emit("ENT", 1);
					type = BOOLEAN;
					printer.endProduction("BaseExpr");
				.)
|
"false"			(.
					printer.print(t.val);
					this.generator.emit("ENT", 0);
					type = BOOLEAN;
					printer.endProduction("BaseExpr");
				.)
|
"read()"		(.
					type = INTEGER;
					this.generator.emit("REA");
				.)
.

IdAccess<out SymbolTable.Symbol symbol>          (.
                                        String name;
                                        symbol = table.new Symbol("undefined", UNDEFINED);
                                     .)
=
identifier		(.
					name = t.val;
					try {
 						symbol = (SymbolTable.Symbol)table.get(name);
 						this.generator.emit("ENT", symbol.address);
					} catch (SymbolTable.SymbolNotFoundException e) {
						SemErr("Undeclared variable " + name);
					}
				 .)
.


Type<out int type>			(. type = UNDEFINED;
					printer.startProduction("Type");
				.)
=
"int"			(.
					printer.print("Type: " + t.val);
					printer.print("Next: " + la.val);
					type = INTEGER;
					printer.endProduction("Type");
				.)
|
"boolean"		(.
					printer.print("Type: " + t.val);
					type = BOOLEAN;
					printer.endProduction("Type");
				.)
.

op<out OpData op>			(. printer.startProduction("op");
					printer.print(la.val);
					op = new OpData();
					op.cw = "";
					op.expected = UNDEFINED;
					op.result = UNDEFINED;
					.)
=
"+"				(.
					op.cw = "ADD";
					op.expected = INTEGER;
					op.result = INTEGER;
				.)
|
"-"				(.
					op.cw = "SUB";
					op.expected = INTEGER;
					op.result = INTEGER;
				.)
|
"*"				(.
					op.cw = "MUL";
					op.expected = INTEGER;
					op.result = INTEGER;
				.)
|
"/"				(.
					op.cw = "DIV";
					op.expected = INTEGER;
					op.result = INTEGER;
				.)
|
"<"				(.
					op.cw = "RLT";
					op.expected = INTEGER;
					op.result = BOOLEAN;
				.)
|
"&&"			(.
					op.cw = "AND";
					op.expected = BOOLEAN;
					op.result = BOOLEAN;
				.)
.

END Grammar.